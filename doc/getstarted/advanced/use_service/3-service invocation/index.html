<h1 id="configure-how-the-service-is-invoked">Configure How the Service is Invoked</h1><p>Typically, you don't need to read through this if a service has only one inport.</p><p>However, you need to understand the following content, if the service has multiple inports, and you need some special behaviors about service is invocated upon message arrival on inports. For example, A service may require that it only executes when all of its inports have data arrived. It would NOT be invoked if only one inport receives a message.</p><p>To give a concrete example, think about a service so called &quot;Full Name&quot;, which has two inports so called &quot;First Name&quot; and &quot;Last Name&quot;. The service would concat the data from &quot;First Name&quot; and &quot;Last Name&quot; to return the &quot;Full Name&quot;. So if a data arrives at the &quot;First Name&quot; inport, the service should NOT immediately be invoked. It should wait untile the &quot;Last Name&quot; also get its data. Then these two data are paired and be used to invoke the Service.</p><p>IoT SOL provides a lot of visually configurable options to customize such behavior to match your really needs. What you need to do is to read the following to understand and use it smartly. :)</p><h2 id="stages-of-service-invocation">Stages of Service Invocation</h2><p>Invocation of a <strong>Service</strong> consists of stages of the following sequence of stages:</p><ol style="list-style-type: decimal"><li><code>Stage: Data Arrivial</code>: A message arrives at the inport of a Service</li><li><code>Stage: Trigger</code>: According to the configuration, it decides whether the data arrival results in the next stage so called <strong>Prepare</strong></li><li><code>Stage: Try to Prepare IN object</code>: Collect the data stored at inports and prepare that as the input (so called IN object) for service invocation. <strong>NOTE</strong> that the <strong>Prepare</strong> could fail to form an IN object (e.g. no data has been arrived on other required inport etc.), and thus would NOT actually invoke the service, i.e. would NOT enter the next stage.</li><li><code>Stage: Service Execution</code>: Really invokes and executes the Service with the IN object. Related messages used to form the IN object would be consumed once. During the excution, sendOUT maybe invoked 0 to N times to send messages through one or multiple its outports.</li></ol><p>As the illustration purpose, we would use the following comparison service as an example. By clicking the Service, it will have an Inspector panel to let us configure the behavior of above stages.</p><div class="figure"><img src="./doc/pic/advanced/use_service/inport.png" class="viewer" /></div><h2 id="stage-data-arrival">Stage: Data Arrival</h2><p>When a message arrives at the inport, before it is consumed to invoke the Service, the inport need to <strong>Store</strong> it first.</p><p>Depends on the mode of that inport, the behavior of <strong>Store</strong> could be different.</p><ul><li><code>Bufferred Mode</code>: In this mode, the inport maintains a buffer (FIFO - First In First Out). The arrived message is stored into the buffer. And would <strong>Removed</strong> after it is consusmed (i.e. used for invocation).</li><li><code>Cached Mode</code>: In this mode, the inport always hold <strong>ONLY</strong> one latest message (could be null or default message if nothing ever arrived, will explain later). That means, the new message would drop the old message no matter whether the old message has been consumed or not. Furthermore, the message is <strong>Still Stored</strong> there even if it has been consumed at least once. It is <strong>NOT Removed</strong> upon consumption.</li></ul><p>So typically in most of the cases, a message sent to <code>Bufferred Mode</code> inport would be used <strong>Once</strong> to invoke the Service, a message sent to <code>Cached Mode</code> inport could be used to invoke the Service by zero or multiple times.</p><p><img src="./doc/pic/advanced/use_service/cache_inport.png" class="viewer" /> <img src="./doc/pic/advanced/use_service/buffer_inport.png" class="viewer" /></p><h2 id="stage-trigger">Stage: Trigger</h2><p>After a message is <strong>Stored</strong>, by default or in MOST of the cases, it would <strong>Trigger</strong> and enter the next stage so called <strong>Prepare</strong>.</p><p>But sometimes, although this is rare, we want that the data arrival at an inport will not result in the next stage. i.e. we simply need data to be stored in this inport, but do NOT want the service be invoked by this.</p><p>For example, there maybe a service so called &quot;Beep Once&quot;. It would have two inports. One is &quot;volume&quot; and the other is &quot;sigal&quot;. If a messasge arrives at &quot;signal&quot;, it would immediately beep once with the volume level stored at &quot;volume&quot;. However, if a message arrives at &quot;volume&quot;, it simply means we would use this new volume level for future beeps, but it should NOT result in a beep.</p><p>We could make this happen by clicking the line of the corresponding inport and it would be visualized to be dotted line, which is so called <strong>No Trigger</strong> mode. <img src="./doc/pic/advanced/use_service/trigger.png" class="viewer" /></p><h2 id="try-to-prepare-in-object">Try to Prepare IN object</h2><p>After it passes the <strong>Trigger</strong> stage, it enters into this <strong>Prepare</strong> stage.</p><p>The major task of this <strong>Prepare</strong> stage is to form an IN object which would be used to invoke the service as input parameters. (You may see the IN is used in code of the Service in <a href="#getstarted/advanced/edit_service/2-service">Edit Service</a>).</p><p>The IN object is formed by firstly fetching the data (the arrived message) from each inport, and then using them to compose an compound object.</p><h3 id="prepare-step-1-read-data-from-inports">Prepare Step 1: Read Data from inports</h3><p>For <code>Bufferred Inport</code>, the data is read from its FIFO, and if no data(i.e. message) in FIFO, it returns <code>undefined</code>.</p><p>For <code>Cached Inport</code>, it returns its stored data (as new data overwrites old data). But if no data (i.e. message) has ever arrived at this inport, it would return a <code>default value</code> (could be configured in Inspector Panel). And if <code>default value</code> isn't configured, it returns <code>undefined</code>.</p><h3 id="prepare-step-2-compose-in-based-on-whether-inports-are-grouped">Prepare Step 2: Compose IN based on whether inports are <code>Grouped</code></h3><p>As you may see, the read data could be <code>undefined</code>, which represents that we failed to get data from corresponding inport. Wether we allow the IN object be composed in case failed to fetech data from certain inport, is determined by another property of the inports, i.e. whether the inports is <code>Grouped</code> or not.</p><div class="figure"><img src="./doc/pic/advanced/use_service/buffer_example.png" class="viewer" /></div><p>The above shows how to set all inports to be <code>Grouped</code>, and it is visualized as a Solid Bar.</p><p><code>Grouped</code> means that all inports should have valid data, and they are paired (i.e. grouped) together to form the IN object.</p><p>So the <strong>Prepare</strong> stage would Sucess and go to next stage if it manages to read data (i.e. no undefined returned) from all of its inports. Otherwise, it would FAIL and will <strong>NOT</strong> enter to the next <code>Execution</code> stage, if the inports are <code>Grouped</code> and failed to read data from at least one of its inports.</p><p>So recall the &quot;First Name&quot; service we talked at the beginning, it could be implemented by set the inports to be <code>Grouped</code>. So the service is only invoked when both &quot;First Name&quot; and &quot;Last Name&quot; has data arrived.</p><p>On the other hand, if it is <code>NOT Grouped</code>, the <strong>Prepare</strong> will always Succeed to form an IN object, although some fields of the IN object could be <code>undefined</code> if failed to read data from a inport.</p><h3 id="typical-combinations-between-grouped-and-bufferred-and-cached">Typical Combinations between <code>Grouped</code> and <code>Bufferred</code> and <code>Cached</code></h3><p>Fail to read data from <code>Cached Inport</code> is typically rare, because normally <code>Cached</code> inport always has something stored there if it has a default value or at least received one message - to be explained later soon, the invocation doesn't remove the data stored in <code>Cached Inport</code>.</p><p>So normally the most frequently used combination is:</p><ul><li><p><code>Cached</code> and <code>NOT Grouped</code>: This is the mode by default for most of the services. For example, the comparion service we shown at the beginning. Everytime a data arrives at either inport (i.e. in1 or in2), the comparison would always happen and would compare with the stored (cached) data in the other inport.</p></li><li><p><code>Bufferred</code> and <code>Grouped</code>: This is typical if the service need data to be paired, i.e. the &quot;Full Name&quot; example.</p></li></ul><p>These are very typical combinations, so when toggle it between <code>Grouped</code> and <code>NOT Grouped</code> in the IDE by clicking the bar, it would automatically to set all inports to <code>Buffered</code> or <code>Cached</code> respectively.</p><h2 id="stage-service-execution">Stage: Service Execution</h2><p>If the <strong>Prepare</strong> stage succeeds and an IN object is formed, the service would be invoked with this IN object as input parameters.</p><h3 id="execution---consume-messages">Execution - Consume Messages</h3><p>Before really start the execution, it would <code>consume</code> the messages that read from the inports and form the IN object.</p><p>To <code>consume</code> the messages:</p><ul><li><p>For <code>Buffered</code> inport, the message read from the inport would be <code>Removed</code> from the FIFO buffer, so a message would be used to invoke the service at most once.</p></li><li><p>For <code>Cached</code> inport, however, as its name implied, it does <code>NOT Remove</code> the message read from the inport, so it remains there and could be used again to invoke the service later.</p></li></ul><h3 id="execution---send-out-messages">Execution - Send Out Messages</h3><p>During the execution, it may invokes <code>sendOUT</code> to send message to its outputs. The <code>sendOUT</code> could be invoked 0 to N times. You may see more details at <a href="#getstarted/advanced/edit_service/2-service">Edit Service</a>).</p><h2 id="sidenotes">Sidenotes</h2><h3 id="auto-trigger-for-heads-of-workflow">Auto Trigger for Heads of workflow</h3><p>Normally, a Service can only be triggered (then prepare and execute) only if one of its inports receive a message. And this message is dispatched to this inport through a line connected to an outport which sends out it.</p><p>However, for a workflow consists of many Services, typically there are Services inside it that has no lines connected to any of its inports. So call these Services as <code>Heads</code> of the workflow.</p><p>For example, the &quot;interval&quot; service of &quot;timer&quot; thing, locates at the left, is the <code>Head</code> of this workflow, as it has no lines connected to its inports</p><div class="figure"><img src="./doc/pic/advanced/use_service/buffer_example.png" class="viewer" /></div><p>When start to execute the workflow, the <code>Heads</code> would be automatically <strong>triggered once</strong>, even though it has no lines connected to inports so have no chance to receive messages.</p><p>So these <code>Heads</code> are actually the entry point of the entire workflow which would send messages to services in rest of the workflow.</p><p>As you could image, as the <code>Heads</code> need to prepare after it is triggered, to ensure the <strong>Prepare</strong> succeed, normally its inports are <code>Cached</code> (so could set <code>default value</code>) and <code>NOT Grouped</code></p><h3 id="no-store-for-received-message">No-Store for Received Message</h3><p>As mentioned above, typically, an arrival of the message would first be stored at that inport, and then enter into trigger stage and then prepare, if the inport is NOT in <strong>No Trigger</strong> mode.</p><p>However, in some rare cases, we want to <strong>SKIP</strong> the <code>Store</code> and directly jump to <code>Trigger</code> stage. For example, sometimes we would like a service always be invoked with its default value in the inport, no matter which kind of message it receives.</p><p>To acoompolish this goal, one could easily set the <strong>line</strong> connected to the inport as <code>No Store</code>, as illustrated below.</p><div class="figure"><img src="./doc/pic/advanced/use_service/no_store.png" class="viewer" /></div>
